<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: addTask_template.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: addTask_template.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// === Global Variables and Priority Setter ===
window.selectedUsers = window.selectedUsers || [];
window.isDropdownOpen = window.isDropdownOpen || false;
window.selectedUserColors = window.selectedUserColors || {};

window.setPriority = function(p) {
  return setPriorityAddTask(p);
};


// === Initialization and Field Validation ===
/**
 * Initializes event handlers for the Add Task template, including title validation
 * and due date formatting and validation.
 */
function initAddTaskTemplateHandlers() {
  const titleInput = document.getElementById("title");
  if (titleInput) {
    const errorMsg = document.getElementById("title-error");
    function validateTitle() {
      const value = titleInput.value.trim();
      if (value === "") {
        errorMsg.textContent = "This field is required.";
        titleInput.style.borderBottom = "1px solid red";
      } else {
        errorMsg.textContent = "";
        titleInput.style.borderBottom = "1px solid #d1d1d1";
      }
    }
    titleInput.addEventListener("blur", validateTitle);
    titleInput.addEventListener("input", validateTitle);
  }
  const dueDateInput = document.getElementById("due-date");
  if (dueDateInput) {
    dueDateInput.addEventListener("input", (e) => {
      sanitizeDueDateInput(e);
      validateDueDate();
    });
    dueDateInput.addEventListener("blur", validateDueDate);
  }
}


// === Assign Dropdown Handling ===
/**
 * Toggles the assign dropdown open or closed and updates placeholder and arrow UI.
 * @param {Event} event - The click event triggering the toggle.
 */
function toggleAssignDropdown(event) {
  event.stopPropagation();
  const dropdown = document.querySelector(".assign-dropdown-addTask_template");
  const placeholder = document.querySelector(".assign-placeholder-addTask_template");
  const arrow = document.querySelector(".assign-arrow-addTask_template");
  if (!dropdown || !placeholder || !arrow) return;
  isDropdownOpen = dropdown.style.display !== "block";
  dropdown.style.display = isDropdownOpen ? "block" : "none";
  if (isDropdownOpen) {
    placeholder.contentEditable = true;
    placeholder.textContent = "";
    placeholder.classList.add("typing");
    placeholder.focus();
    arrow.style.transform = "rotate(180deg)"; 
    const items = document.querySelectorAll(".assign-item-addTask_template");
    items.forEach((item) => (item.style.display = "flex"));
  } else {
    placeholder.contentEditable = false;
    placeholder.classList.remove("typing");
    placeholder.blur();
    arrow.style.transform = "rotate(0deg)"; 
    placeholder.textContent = "Select contact to assign";
    placeholder.style.color = "black";
  }
  if (!isDropdownOpen) {
    renderAssignedAvatars();
  }
}


// === Shared helper: Extract avatar/user color ===
/**
 * Extracts a background color from an assign item, avatar element, CSS variable,
 * or fallback sources.
 * @param {HTMLElement} item - The DOM element representing a contact item.
 * @returns {string} The resolved color value.
 */
function getColorFromItem(item) {
  if (!item) return "#4589ff";
  const avatarEl =
    item.querySelector(".assign-avatar-addTask_template") ||
    item.querySelector(".assign-avatar-addTask_page");
  if (avatarEl) {
    let c = avatarEl.style.backgroundColor;
    if (!c) c = getComputedStyle(avatarEl).backgroundColor;
    if (c &amp;&amp; c !== "transparent" &amp;&amp; c !== "rgba(0, 0, 0, 0)") return c;
    const varCol = getComputedStyle(avatarEl)
      .getPropertyValue("--avatar-color")
      .trim();
    if (varCol) return varCol;
  }
  const colorEl =
    item.querySelector('[class*="color"]') ||
    item.querySelector('[class*="avatar"]') ||
    item;
  if (colorEl) {
    let c = colorEl.style.backgroundColor || getComputedStyle(colorEl).backgroundColor;
    if (c &amp;&amp; c !== "transparent" &amp;&amp; c !== "rgba(0, 0, 0, 0)") return c;
  }
  const dataColor = item.getAttribute("data-color");
  if (dataColor) return dataColor;
  return "#4589ff";
}


// === Assign User Selection ===
/**
 * Selects or deselects a user from the assign dropdown and updates
 * selected user tracking and color mapping.
 * @param {string} name - The name of the user to select.
 * @param {Event} event - The click event that triggered the selection.
 */
function selectAssignUser(name, event) {
  if (event &amp;&amp; event.stopPropagation) event.stopPropagation();
  let item = event &amp;&amp; event.currentTarget ? event.currentTarget : null;
  if (!item) {
    const candidates = document.querySelectorAll(".assign-item-addTask_template");
    candidates.forEach((el) => {
      const label = el
        .querySelector(".assign-name-addTask_template")
        .textContent.trim();
      if (!item &amp;&amp; label === name) item = el;
    });
  }
  if (!item) return;
  const checkbox = item.querySelector(".assign-check-addTask_template");
  item.classList.toggle("selected", checkbox.checked);
  if (checkbox.checked) {
    if (!selectedUsers.includes(name)) selectedUsers.push(name);
        if (window.selectedUserColors) {
      const color = getColorFromItem(item) || "#4589ff";
      window.selectedUserColors[name] = color;
    }
  } else {
    selectedUsers = selectedUsers.filter((user) => user !== name);
        if (window.selectedUserColors) delete window.selectedUserColors[name];
  }
  updateAssignPlaceholder();
}


// === Assign Input Filtering ===
/**
 * Updates the assign placeholder text depending on whether users are selected.
 */
function updateAssignPlaceholder() {
  const placeholder = document.querySelector(".assign-placeholder-addTask_template");
  if (selectedUsers.length === 0) {
    placeholder.textContent = "Select contact to assign";
    placeholder.style.color = "black";
  } else {
    placeholder.textContent = "";
  }
}


/**
 * Handles live filtering of assign dropdown items based on user input.
 */
document.addEventListener("input", (e) => {
  if (e.target.classList.contains("assign-placeholder-addTask_template")) {
    const searchValue = e.target.textContent.toLowerCase();
    const items = document.querySelectorAll(".assign-item-addTask_template");
    if (searchValue.trim() === "") {
      items.forEach((item) => (item.style.display = "flex"));
      return;
    }
    let anyMatch = false;
    items.forEach((item) => {
      const name = item.querySelector(".assign-name-addTask_template").textContent.toLowerCase();
      if (name.includes(searchValue)) {
        item.style.display = "flex";
        anyMatch = true;
      } else {
        item.style.display = "none";
      }
      if (
        e.target.classList.contains("assign-placeholder-addTask_template") &amp;&amp;
        e.target.textContent.trim() === ""
      ) {
        updateAssignPlaceholder();
      }
    });
    if (!anyMatch) {
      items.forEach((item) => (item.style.display = "flex"));
    }
  }
});


// === Assign Dropdown Close Handling ===
/**
 * Detects clicks outside the assign dropdown to close it and reset UI state.
 */
document.addEventListener("click", (e) => {
  const dropdown = document.querySelector(".assign-dropdown-addTask_template");
  const assignSelect = document.getElementById("assign-select");
  const placeholder = document.querySelector(".assign-placeholder-addTask_template");
  const arrow = document.querySelector(".assign-arrow-addTask_template");
  if (!dropdown || !assignSelect) return;
  if (!assignSelect.contains(e.target) &amp;&amp; !dropdown.contains(e.target)) {
    dropdown.style.display = "none";
    placeholder.contentEditable = false;
    placeholder.classList.remove("typing");
    arrow.style.transform = "rotate(0deg)";
    renderAssignedAvatars();
  }
});


// === Assigned Avatars Rendering ===
/**
 * Renders avatars for all currently selected users, including initials and colors.
 */
function renderAssignedAvatars() {
  const container = document.getElementById("assigned-avatars");
  if (!container) return;
  container.innerHTML = ""; 
  const getColorFromItem = (item) => {
    if (!item) return "";
       const avatarEl = item.querySelector(".assign-avatar-addTask_template");
       if (avatarEl) {
         let c = avatarEl.style.backgroundColor;
         if (!c) c = getComputedStyle(avatarEl).backgroundColor;
         if (!c || c === "transparent" || c === "rgba(0, 0, 0, 0)") {
           const varCol = getComputedStyle(avatarEl).getPropertyValue("--avatar-color").trim();
           if (varCol) c = varCol;
         }
         if (c &amp;&amp; c !== "transparent" &amp;&amp; c !== "rgba(0, 0, 0, 0)") return c;
       }
    const colorEl =
    item.querySelector('[class*="color"]') ||
    item.querySelector('[class*="avatar"]') ||
    item;
  if (colorEl) {
    let c = colorEl.style.backgroundColor || getComputedStyle(colorEl).backgroundColor;
    if (c &amp;&amp; c !== "transparent" &amp;&amp; c !== "rgba(0, 0, 0, 0)") return c;
  }
  const dataColor = item.getAttribute("data-color");
  if (dataColor) return dataColor;
  return "#4589ff";
};
(window.selectedUsers || []).forEach((name) => {
  const item = [...document.querySelectorAll(".assign-item-addTask_template")].find(
    (el) =>
      el.querySelector(".assign-name-addTask_template")?.textContent.trim() === name
  );
    let color = window.selectedUserColors?.[name];
  if (!color) {
    color = getColorFromItem(item) || "#4589ff";
    if (window.selectedUserColors) window.selectedUserColors[name] = color;
  }
    const initials = name
      .split(" ")
      .map((n) => n[0]?.toUpperCase())
      .join("");
      const avatar = document.createElement("div");
      avatar.textContent = initials;
      avatar.classList.add("assign-avatar-addTask_template", "assign-avatar-addTask_page");
      avatar.style.backgroundColor = color;
      avatar.dataset.fullName = name;
      avatar.dataset.color = color;
      avatar.title = name;
      container.appendChild(avatar);
  });
}


// === Priority Handling ===
/**
 * Sets the priority for the task and updates corresponding button styles.
 * @param {string} priority - One of "urgent", "medium", or "low".
 */
function setPriorityAddTask(priority) {
  const urgentBtn = document.querySelector(".priority-btn-urgent-addTask_template");
  const mediumBtn = document.querySelector(".priority-btn-medium-addTask_template");
  const lowBtn = document.querySelector(".priority-btn-low-addTask_template");
  urgentBtn.style.backgroundColor = "white";
  mediumBtn.style.backgroundColor = "white";
  lowBtn.style.backgroundColor = "white";
  urgentBtn.style.color = "black";
  mediumBtn.style.color = "black";
  lowBtn.style.color = "black";
  urgentBtn.querySelector("img").style.filter = "";
  mediumBtn.querySelector("img").style.filter =
    "brightness(0) saturate(100%) invert(68%) sepia(94%) saturate(312%) hue-rotate(360deg) brightness(101%) contrast(102%)";
  lowBtn.querySelector("img").style.filter = "";
  if (priority === "urgent") {
    urgentBtn.style.backgroundColor = "#ff3d00";
    urgentBtn.style.color = "white";
    urgentBtn.querySelector("img").style.filter = "brightness(0) invert(1)";
  } else if (priority === "medium") {
    mediumBtn.style.backgroundColor = "#ffa800";
    mediumBtn.style.color = "white";
    mediumBtn.querySelector("img").style.filter = "brightness(0) invert(1)";
  } else if (priority === "low") {
    lowBtn.style.backgroundColor = "#00c853";
    lowBtn.style.color = "white";
    lowBtn.querySelector("img").style.filter = "brightness(0) invert(1)";
  }
  window.currentPriority = priority;
  window.currentPrio = priority;
}


// === Subtask Management (Add, Edit, Remove, Save) ===
/**
 * Handles adding, editing, saving, and removing subtasks within the Add Task template.
 */
document.addEventListener("click", (e) => {
  if (e.target.classList.contains("subtask-delete-addTask_template")) {
    const subtaskInput = document.getElementById("subtask");
    if (subtaskInput) subtaskInput.value = "";
  }
  if (e.target.classList.contains("subtask-check-addTask_template")) {
    const subtaskInput = document.getElementById("subtask");
    const subtaskList = document.getElementById("subtask-list");
    const value = subtaskInput.value.trim();
    if (value !== "") {
      const li = document.createElement("li");
      li.textContent = value;
      const actions = document.createElement("div");
      actions.classList.add("subtask-actions-addTask_template");
      actions.innerHTML = `
        &lt;img src="../assets/img/edit.svg" alt="Edit subtask" class="subtask-edit-addTask_template">
        &lt;div class="subtask-divider-addTask_template">&lt;/div>
        &lt;img src="../assets/img/delete.svg" alt="Delete subtask" class="subtask-remove-addTask_template">
      `;
      li.appendChild(actions);
      subtaskList.appendChild(li);
      subtaskInput.value = "";
    }
  }
  if (e.target.classList.contains("subtask-remove-addTask_template")) {
    const li = e.target.closest("li");
    if (li) li.remove();
  }
  if (e.target.classList.contains("subtask-edit-addTask_template")) {
    const li = e.target.closest("li");
    if (!li) return;
    const oldText = li.firstChild.textContent;
    li.innerHTML = "";

    const input = document.createElement("input");
    input.type = "text";
    input.value = oldText.trim();
    input.classList.add("task-subtask-addTask_template");

    const actions = document.createElement("div");
    actions.classList.add("subtask-actions-addTask_template");
    actions.innerHTML = `
      &lt;img src="../assets/img/delete.svg" alt="Delete subtask" class="subtask-remove-addTask_template">
      &lt;div class="subtask-divider-addTask_template">&lt;/div>
      &lt;img src="../assets/img/check.svg" alt="Save subtask" class="subtask-save-addTask_template">
    `;
    li.appendChild(input);
    li.appendChild(actions);
  }
  if (e.target.classList.contains("subtask-save-addTask_template")) {
    const li = e.target.closest("li");
    const input = li.querySelector("input");
    const newText = input.value.trim();
    if (!newText) return;
    li.innerHTML = "";
    li.textContent = newText;

    const actions = document.createElement("div");
    actions.classList.add("subtask-actions-addTask_template");
    actions.innerHTML = `
      &lt;img src="../assets/img/edit.svg" alt="Edit subtask" class="subtask-edit-addTask_template">
      &lt;div class="subtask-divider-addTask_template">&lt;/div>
      &lt;img src="../assets/img/delete.svg" alt="Delete subtask" class="subtask-remove-addTask_template">
    `;
    li.appendChild(actions);
  }
});


// === Due Date Validation and Formatting ===
/**
 * Sanitizes date input to allow only digits and slashes, enforcing max length.
 * @param {InputEvent} e - The input event.
 */
function sanitizeDueDateInput(e) {
  const input = e.target;
  input.value = input.value.replace(/[^0-9/]/g, "").slice(0, 10);
}


/**
 * Checks if a date string matches the dd/mm/yyyy format.
 * @param {string} dateString - The date string to validate.
 * @returns {boolean} True if the format is valid.
 */
function isValidDateFormat(dateString) {
  return /^\d{2}\/\d{2}\/\d{4}$/.test(dateString);
}


/**
 * Determines whether the given date string represents a real valid calendar date.
 * @param {string} dateString - A dd/mm/yyyy formatted date.
 * @returns {boolean} True if the date exists.
 */
function isRealDate(dateString) {
  const [d, m, y] = dateString.split("/").map(Number);
  const date = new Date(y, m - 1, d);
  return (
    date &amp;&amp;
    date.getDate() === d &amp;&amp;
    date.getMonth() === m - 1 &amp;&amp;
    date.getFullYear() === y
  );
}


/**
 * Validates the due date input field for presence, format, and correctness.
 * @returns {boolean} True if the due date passes all validations.
 */
function validateDueDate() {
  const dueDateInput = document.getElementById("due-date");
  const errorMsg = document.getElementById("due-date-error");
  if (!dueDateInput || !errorMsg) return;
  const value = dueDateInput.value.trim();
  if (!value) {
    errorMsg.textContent = "This field is required.";
    dueDateInput.style.borderBottom = "1px solid red";
    return false;
  }
  if (!isValidDateFormat(value)) {
    errorMsg.textContent = "Use format dd/mm/yyyy.";
    dueDateInput.style.borderBottom = "1px solid red";
    return false;
  }
  if (!isRealDate(value)) {
    errorMsg.textContent = "Invalid date.";
    dueDateInput.style.borderBottom = "1px solid red";
    return false;
  }
  errorMsg.textContent = "";
  dueDateInput.style.borderBottom = "1px solid #d1d1d1";
  return true;
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#getColorFromItem">getColorFromItem</a></li><li><a href="global.html#initAddTaskTemplateHandlers">initAddTaskTemplateHandlers</a></li><li><a href="global.html#isRealDate">isRealDate</a></li><li><a href="global.html#isValidDateFormat">isValidDateFormat</a></li><li><a href="global.html#renderAssignedAvatars">renderAssignedAvatars</a></li><li><a href="global.html#sanitizeDueDateInput">sanitizeDueDateInput</a></li><li><a href="global.html#selectAssignUser">selectAssignUser</a></li><li><a href="global.html#setPriorityAddTask">setPriorityAddTask</a></li><li><a href="global.html#toggleAssignDropdown">toggleAssignDropdown</a></li><li><a href="global.html#updateAssignPlaceholder">updateAssignPlaceholder</a></li><li><a href="global.html#validateDueDate">validateDueDate</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Fri Nov 21 2025 13:33:06 GMT+0100 (Central European Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
